source,jumlah_var,skor
                    break,0,0
                    pass  # print 'exchanged',0,0
                break,0,0
                else:,0,0
"                flag_exchange, curr_subset = self.check_exchange_greedy(g_m, curr_subset, ground_set, approx, K)",6,0.6
                if flag_exchange:,1,0.1
                ind_e = np.where(subset == e)[0],3,0.3
                pass,0,0
                print 'no increment',0,0
                return subset,1,0.1
                return subset,1,0.1
                return subset,1,0.1
                return subset,1,0.1
                return subset_old,1,0.1
"                return True, subset",2,0.2
"                return True, subset_with_null",2,0.2
                subset[ind_e] = d,2,0.2
"                subset_choosen = np.array(random.sample(subset_c, s))",5,0.5
                subset_choosen = subset_c,2,0.2
                subset_old = subset,2,0.2
                subset_old = subset,2,0.2
"                subset_sel = self.distort_greedy(g, self.K, gamma)",4,0.4
"                subset_sel = self.stochastic_distort_greedy(g, self.K, gamma, delta)",5,0.5
                subset_with_null[r] = d,2,0.2
                val_old = val_curr,1,0.1
"            bcur = bcur.reshape(X.shape[1], 1)",3,0.3
"            bcur = bcur.reshape(X.shape[1], 1)",3,0.3
"            bcur = self.hard_threshold((P_X.dot(bcur) + (np.eye(X.shape[1]) - P_X).dot(y)).reshape(X.shape[1]), self.K)",7,0.7
"            bcur = self.hard_threshold((P_X.dot(bcur) + (np.eye(X.shape[1]) - P_X).dot(y)).reshape(X.shape[1]), self.K)",7,0.7
            bprev = np.copy(tmp),2,0.2
            bprev = np.copy(tmp),2,0.2
            c_mod_inc = c_mod.get_inc_arr(subset).flatten(),2,0.2
"            c_mod_inc = c_mod.get_inc_arr(subset, rest_flag=True, subset_rest=subset_choosen)",4,0.4
"            curr_set = self.get_added(curr_set, idx_to_add)",3,0.3
"            curr_set = self.get_added(curr_set, idx_to_add)",3,0.3
            d = subset_c_gr[c],2,0.2
            delta = 0.05,1,0.1
            e = subset_with_null[r],2,0.2
            elm = subset_c[sel_ind],2,0.2
            elm = subset_choosen[sel_ind],2,0.2
            else:,0,0
            else:,0,0
            else:,0,0
            else:,0,0
            else:,0,0
            else:,0,0
"            f = F({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",5,0.5
"            f = F({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",5,0.5
"            flag_delete, curr_subset = self.check_delete(g_m, curr_subset, approx)",5,0.5
            frac = (1 - gamma / float(K)) ** (K - itr - 1),4,0.4
            frac = (1 - gamma / float(K)) ** (K - itr - 1),4,0.4
            g.update_data_str(elm),2,0.2
            g.update_data_str(elm),2,0.2
            g.update_data_str(idx_to_add),2,0.2
"            g_inc_arr, subset_c_ret = g.get_inc_arr(subset)",4,0.4
"            g_inc_arr, subset_c_ret = g.get_inc_arr(subset, rest_flag=True, subset_rest=subset_choosen)",6,0.6
"            g_m = SubMod({'X': self.X, 'lamb': self.lamb, 'm': m_f})",4,0.4
"            g_m = SubMod({'X': self.X, 'lamb': self.lamb, 'm': m_f})",4,0.4
            g_pos_inc = g_inc_arr + c_mod_inc,3,0.3
            g_pos_inc = g_inc_arr.flatten() + c_mod_inc,3,0.3
            G_subset.append(g.eval(subset_sel)),2,0.2
            gamma = gamma * (1 - delta),3,0.3
            idx_to_add = subset_left[np.argmax(vector)],3,0.3
            idx_to_add = subset_left[np.argmax(vector)],3,0.3
            if e == -1:,1,0.1
            if flag_delete:,1,0.1
            if flag_stochastic:,1,0.1
            if np.max(inc_vec) <= 0:,2,0.2
            if np.max(inc_vec) <= 0:,2,0.2
            if np.max(vector) <= 0:,2,0.2
            if s < subset_c.shape[0]:,2,0.2
            if set(subset) == set(subset_old):,2,0.2
            if set(subset) == set(subset_old):,2,0.2
            if val_curr <= val_old:,2,0.2
            inc_vec = frac * g_pos_inc - c_mod_inc,4,0.4
            inc_vec = frac * g_pos_inc - c_mod_inc,4,0.4
            item_to_del = subset[np.argmax(g_m_subset_vector)],3,0.3
            itr += 1,1,0.1
            itr += 1,1,0.1
            m_f = f.modular_upper_bound(subset_old),3,0.3
            m_f = f.modular_upper_bound(subset_old),3,0.3
"            print 'subset length', subset.shape",1,0.1
"            r, c = np.unravel_index(np.argmax(g_m_exchange, axis=None), g_m_exchange.shape)",7,0.7
"            return False, subset",1,0.1
            return subset_1,1,0.1
            return subset_2,1,0.1
"            return True, subset_left",1,0.1
            sel_ind = np.argmax(inc_vec),3,0.3
            sel_ind = np.argmax(inc_vec),3,0.3
            self.c = data_dict['c'],2,0.2
            self.c = np.square(data_dict['human_pred'] - data_dict['Y']),4,0.4
"            subset = self.constr_submod_max(g_m, self.K)",4,0.4
"            subset = self.constr_submod_max_greedy(g_m, self.K)",4,0.4
            subset = self.CRR_Reg(),2,0.2
            subset = self.CRR_subset(),2,0.2
            subset = self.gamma_sweep_distort_greedy(flag_stochastic=True),3,0.3
"            subset = self.gamma_sweep_distort_greedy(T=param['DG_T'], flag_stochastic=False)",4,0.4
"            subset = self.get_added(subset, elm)",4,0.4
"            subset = self.get_added(subset, elm)",4,0.4
            subset = self.kl_triage_subset(),2,0.2
            subset = self.max_submod_greedy(),2,0.2
            subset = self.sel_subset_diff_submod(),2,0.2
            subset = self.sel_subset_diff_submod_greedy(),2,0.2
            subset[str(r)] = subset_sel,2,0.2
            subset_c = self.get_c(subset),3,0.3
            subset_c = self.get_c(subset),3,0.3
"            subset_left = self.get_minus(subset, item_to_del)",4,0.4
            tmp = np.copy(bcur),3,0.3
            tmp = np.copy(bcur),3,0.3
            v[vsorteddec[i]] = 0,2,0.2
            val_curr = g_f.eval(subset),3,0.3
"            vector, subset_left = g.get_inc_arr(curr_set)",4,0.4
"            vector, subset_left = g_m.get_inc_arr(curr_set)",4,0.4
            w_m = 0,1,0.1
            w_m = self.get_optimal_pred(subset),3,0.3
        approx = 1 + self.epsilon / float(self.n ** 4),3,0.3
        bcur = np.zeros(y.shape),3,0.3
        bcur = np.zeros(y.shape),3,0.3
"        bprev = np.random.uniform(10, 20, y.shape)",3,0.3
"        bprev = np.random.uniform(10, 20, y.shape)",3,0.3
"        c_mod = modular_distort_greedy({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",6,0.6
"        c_mod = modular_distort_greedy({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",6,0.6
        c_subset = self.get_c(subset),3,0.3
        curr_set = np.array([]).astype(int),2,0.2
        curr_set = np.array([]).astype(int),2,0.2
        curr_subset = np.array([g_m.find_max_elm(ground_set)]),4,0.4
        else:,0,0
        else:,0,0
        else:,0,0
        empty_set = np.array([]).astype(int),2,0.2
        finish = time.time(),2,0.2
"        for i in range(k, v.shape[0]):",3,0.3
        for itr in range(K):,2,0.2
        for itr in range(K):,2,0.2
        for itr in range(K):,2,0.2
        for itr in range(self.K):,2,0.2
        for r in range(T + 1):,2,0.2
"        g = G({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",6,0.6
"        g = G({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",6,0.6
        g.reset(),1,0.1
        g.reset(),1,0.1
"        g_f = G({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",6,0.6
"        g_m_exchange, subset_with_null, subset_c_gr = g_m.eval_exch_or_add(subset, ground_set, K)",7,0.7
        g_m_subset = g_m.eval(subset),3,0.3
        g_m_subset = g_m.eval(subset),3,0.3
        g_m_subset_vector = g_m.eval_vector(subset),3,0.3
        G_subset = [],1,0.1
        G_subset.append(g.eval(empty_set)),3,0.3
        gamma = 1.0,1,0.1
        ground_set = self.get_c(subset_1),2,0.2
        ground_set = self.V,1,0.1
        if g_m.eval(subset_1) > g_m.eval(subset_2):,4,0.4
        if np.max(g_m_exchange) > g_m_subset * approx:,4,0.4
        if np.max(g_m_subset_vector) >= g_m_subset * approx:,4,0.4
        if optim == 'diff_submod':,1,0.1
        if optim == 'diff_submod_greedy':,1,0.1
        if optim == 'distort_greedy':,1,0.1
        if optim == 'greedy':,1,0.1
        if optim == 'kl_triage':,1,0.1
        if optim == 'RLSR':,1,0.1
        if optim == 'RLSR_Reg':,1,0.1
        if optim == 'stochastic_distort_greedy':,1,0.1
        if real:,1,0.1
        if subset.shape[0] == self.n:,3,0.3
        if subset.size == 0:,2,0.2
        if T != 5:,1,0.1
        itr = 0,1,0.1
        itr = 0,1,0.1
"        kl_obj = kl_triage({'X': self.X, 'Y': self.Y, 'c': self.c, 'lamb': self.lamb})",9,0.9
        max_set_ind = np.argmax(np.array(G_subset)),3,0.3
        P_X = (Xtr.dot(XXtrInv)).dot(X),3,0.3
        P_X = (Xtr.dot(XXtrInv)).dot(X),3,0.3
        plt_obj = {},1,0.1
"        plt_obj = {'w': w_m, 'subset': subset}",4,0.4
"        plt_obj['human'] = {'x': x, 'y': y}",5,0.5
"        plt_obj['machine'] = {'x': x, 'y': y}",5,0.5
"        plt_obj['prediction'] = {'x': x, 'y': y, 'w': w}",7,0.7
"        print 'subset_size', s, 'K-->', K, ', n --> ', self.n",6,0.6
"        print 'Time -- > ', (finish - start)",2,0.2
        return curr_set,1,0.1
        return curr_set,1,0.1
        return curr_subset,1,0.1
"        return False, subset",2,0.2
"        return False, subset",2,0.2
        return kl_obj.get_subset(self.K),2,0.2
        return LA.inv(self.lamb * subset_c_l * np.eye(self.dim) + X_sub.dot(X_sub.T)).dot(X_sub.dot(Y_sub)),10,1
        return np.array([i for i in subset if i != elm]),2,0.2
        return np.array([int(i) for i in self.V if i not in subset]),2,0.2
"        return np.concatenate((subset, np.array([int(elm)])), axis=0)",5,0.5
        return plt_obj,1,0.1
        return plt_obj,1,0.1
        return subset,1,0.1
        return subset,1,0.1
        return subset,1,0.1
        return subset,1,0.1
        return subset[str(max_set_ind)],3,0.3
        return v,1,0.1
        s = int(math.ceil(self.n * np.log(float(1) / epsilon) / float(K))),7,0.7
        self.BIG_VALUE = 100000,1,0.1
        self.dim = self.X.shape[1],2,0.2
        self.epsilon = float(1),2,0.2
        self.K = K,1,0.1
        self.lamb = lamb,1,0.1
        self.n = self.X.shape[0],2,0.2
        self.real = real,1,0.1
"        self.set_param(param['lamb'], int(param['K'] * self.n))",7,0.7
        self.V = np.arange(self.n),2,0.2
        self.X = data_dict['X'],2,0.2
        self.Y = data_dict['Y'],2,0.2
        start = time.time(),1,0.1
        Submod_ratio = 0.7,1,0.1
        subset = [i for i in range(len(bcur)) if bcur[i] != 0],5,0.5
        subset = [i for i in range(len(bcur)) if bcur[i] != 0],5,0.5
        subset = {},1,0.1
        subset = np.array([]).astype(int),3,0.3
        subset = np.array([]).astype(int),3,0.3
        subset = np.array(subset),2,0.2
        subset = np.array(subset),2,0.2
        subset[str(T + 1)] = empty_set,3,0.3
"        subset_1 = self.approx_local_search(g_m, K, ground_set)",4,0.4
"        subset_2 = self.approx_local_search(g_m, K, ground_set)",4,0.4
        subset_c = self.get_c(subset),2,0.2
        subset_c_l = self.n - subset.shape[0],3,0.3
        subset_old = np.array([]),2,0.2
        subset_old = np.array([]),2,0.2
        tolerance = .001,1,0.1
        tolerance = .001,1,0.1
        val_old = g_f.eval(subset_old),3,0.3
        vsorted = np.argsort(v),2,0.2
        vsorteddec = vsorted[::-1],2,0.2
        w = (XXtrInv.dot(X)).dot(y - bcur),3,0.3
        w = (XXtrInv.dot(X)).dot(y - bcur),3,0.3
        w = w.reshape(w.shape[0]),3,0.3
        w = w.reshape(w.shape[0]),3,0.3
        while LA.norm(bcur - bprev) > tolerance:,3,0.3
        while LA.norm(bcur - bprev) > tolerance:,3,0.3
        while True:,1,0.1
        while True:,1,0.1
        while True:,1,0.1
"        X = np.swapaxes(X, 1, 0)",3,0.3
"        X = np.swapaxes(X, 1, 0)",3,0.3
        X = self.X,2,0.2
        X = self.X,2,0.2
"        x = self.X[:, 0].flatten()",2,0.2
"        x = self.X[c_subset, 0].flatten()",2,0.2
"        x = self.X[subset, 0].flatten()",2,0.2
        X_sub = self.X[subset_c].T,2,0.2
        Xtr = X.T,3,0.3
        Xtr = X.T,3,0.3
        XXtr = X.dot(Xtr),3,0.3
        XXtr = X.dot(Xtr),3,0.3
        XXtr = XXtr + self.lamb * np.eye(self.dim)  # regularized,5,0.5
        XXtrInv = LA.inv(XXtr),3,0.3
        XXtrInv = LA.inv(XXtr),3,0.3
        y = self.X.dot(w).flatten(),2,0.2
        y = self.Y,2,0.2
        y = self.Y,3,0.3
        y = self.Y[c_subset],3,0.3
        y = self.Y[subset],3,0.3
"        y = y.reshape(y.shape[0], 1)",3,0.3
"        y = y.reshape(y.shape[0], 1)",3,0.3
        Y_sub = self.Y[subset_c],4,0.4
"    def __init__(self, data_dict, real=None):",4,0.4
"    def algorithmic_triage(self, param, optim):",4,0.4
"    def approx_local_search(self, g_m, K, ground_set):",5,0.5
"    def check_delete(self, g_m, subset, approx):",5,0.5
"    def check_exchange_greedy(self, g_m, subset, ground_set, approx, K):",7,0.7
"    def constr_submod_max(self, g_m, K):",4,0.4
"    def constr_submod_max_greedy(self, g_m, K):",4,0.4
    def CRR_Reg(self):,2,0.2
    def CRR_subset(self):,2,0.2
"    def distort_greedy(self, g, K, gamma):",5,0.5
"    def gamma_sweep_distort_greedy(self, delta=0.01, T=5, flag_stochastic=None):",5,0.5
"    def get_added(self, subset, elm):",4,0.4
"    def get_c(self, subset):",3,0.3
"    def get_minus(self, subset, elm):",4,0.4
"    def get_optimal_pred(self, subset):",3,0.3
"    def hard_threshold(self, v, k):",4,0.4
    def kl_triage_subset(self):,2,0.2
    def max_submod_greedy(self):,2,0.2
"    def plot_subset(self, w, subset):",4,0.4
    def sel_subset_diff_submod(self):,2,0.2
    def sel_subset_diff_submod_greedy(self):,2,0.2
"    def set_param(self, lamb, K):",4,0.4
"    def stochastic_distort_greedy(self, g, K, gamma, epsilon):",6,0.6
class triage_human_machine:,1,0.1
from baseline_classes import *,1,0.1
import math,1,0.1
import numpy as np,1,0.1
import numpy.linalg as LA,1,0.1
import random,1,0.1
import time,1,0.1
